# JourneyForge DSL – Use Case Catalog

Status: Draft | Last updated: 2025-11-20

This catalog collects concrete JourneyForge use cases and links them to example journey definitions, OpenAPI exports, and DSL patterns. Each use case has its own page under `docs/2-how-to/use-cases/` with end‑to‑end samples.

## Use Cases

| Use case | Description | Example specs |
|----------|-------------|---------------|
| [Third‑party auth & propagation](auth-third-party.md) | Use inbound auth (JWT/mTLS/API key) and `httpBindings` to normalise identity into `context`, then use outbound auth (OAuth2 client credentials) for downstream calls. | [`auth-user-info.journey.yaml`](../../3-reference/examples/auth-user-info.journey.yaml), [`auth-outbound-client-credentials.journey.yaml`](../../3-reference/examples/auth-outbound-client-credentials.journey.yaml) |
| [Synchronous API endpoint (no journeys)](api-endpoint-sync.md) | Expose a single HTTP endpoint (`kind: Api`) that calls one or more downstream APIs and returns a composed result without journey ids or status polling. | [`http-chained-calls-api.journey.yaml`](../../3-reference/examples/http-chained-calls-api.journey.yaml) |
| [HTTP notification (fire-and-forget)](http-notify-audit.md) | Trigger best-effort audit/notification calls using `task.mode: notify` and continue without observing the HTTP outcome. | [`http-notify-audit.journey.yaml`](../../3-reference/examples/http-notify-audit.journey.yaml) |
| [Event publish to Kafka](event-publish-kafka.md) | Emit domain events to Kafka using `task.kind: eventPublish` with key/value mappers and JSON Schemas. | [`event-publish-kafka.journey.yaml`](../../3-reference/examples/event-publish-kafka.journey.yaml) |
| [Request multiplexing & composition](request-multiplexing.md) | Call multiple HTTP APIs and combine their responses, including chained calls and conditional composition. | [`http-chained-calls.journey.yaml`](../../3-reference/examples/http-chained-calls.journey.yaml), [`http-aggregate-errors.journey.yaml`](../../3-reference/examples/http-aggregate-errors.journey.yaml), [`http-conditional-composition.journey.yaml`](../../3-reference/examples/http-conditional-composition.journey.yaml) |
| [Trace/header propagation](header-propagation.md) | Capture inbound trace IDs and propagate them to all downstream HTTP tasks without repeating headers in every state. | [`http-header-interpolation.journey.yaml`](../../3-reference/examples/http-header-interpolation.journey.yaml) |
| [Cache‑aware profile lookup](cache-user-profile.md) | Use `transform` + `cacheGet`/`cachePut` to avoid redundant upstream calls by caching user data. | [`cache-user-profile.journey.yaml`](../../3-reference/examples/cache-user-profile.journey.yaml) |
| [External approval & callbacks](external-input-approval.md) | Pause journeys at `wait`/`webhook` states, resume on manual approval or third‑party callbacks, and expose `/steps/{stepId}` endpoints. | [`wait-approval.journey.yaml`](../../3-reference/examples/wait-approval.journey.yaml), [`payment-callback.journey.yaml`](../../3-reference/examples/payment-callback.journey.yaml) |
| [Error handling & Problem Details](error-handling-problem-details.md) | Detect upstream failures/timeouts, normalise them into RFC 9457 Problem Details, and either return or fail with mapped error codes. | [`http-failure-branch.journey.yaml`](../../3-reference/examples/http-failure-branch.journey.yaml), [`http-timeout-branch.journey.yaml`](../../3-reference/examples/http-timeout-branch.journey.yaml), [`http-problem-details.journey.yaml`](../../3-reference/examples/http-problem-details.journey.yaml) |
| [API error mapping with `spec.errors` + `spec.apiResponses`](api-error-mapping-spec-errors-and-apiResponses.md) | Combine canonical Problem Details, a single journey-wide error envelope, and declarative HTTP status mapping rules for `kind: Api` endpoints. | *(example `kind: Api` spec TBD; reuses patterns from `http-problem-details.journey.yaml` and `http-custom-error-envelope.journey.yaml`)* |
| [Parallel credit decision](parallel-credit-decision.md) | Call risk/limits/KYC services in parallel and make a combined approve/reject decision. | [`credit-decision-parallel.journey.yaml`](../../3-reference/examples/credit-decision-parallel.journey.yaml) |
| [Resilience policies & degraded mode](http-resilience-degrade.md) | Use httpResilience policies to retry unstable calls and fail with a degraded status if all attempts fail. | [`http-resilience-degrade.journey.yaml`](../../3-reference/examples/http-resilience-degrade.journey.yaml) |
| [Idempotent create‑if‑not‑exists](http-idempotent-create.md) | Implement create‑or‑get semantics using GET+POST and explicit branching on HTTP status. | [`http-idempotent-create.journey.yaml`](../../3-reference/examples/http-idempotent-create.journey.yaml) |
| [Transform‑only pipeline](transform-pipeline.md) | Run a multi‑step DataWeave transform pipeline without any HTTP calls. | [`transform-pipeline.journey.yaml`](../../3-reference/examples/transform-pipeline.journey.yaml) |
| [Multi‑tenant routing](multitenant-routing.md) | Route to different upstream APIs based on tenant id from headers. | [`multitenant-routing.journey.yaml`](../../3-reference/examples/multitenant-routing.journey.yaml) |
| [Named outcomes & reporting](named-outcomes.md) | Classify outcomes with spec.outcomes to distinguish success/failure reasons. | [`named-outcomes.journey.yaml`](../../3-reference/examples/named-outcomes.journey.yaml) |
| [Sync wrapper over wait](sync-wrapper-wait.md) | Use a wait state with timeout to represent long‑running operations with clear timeout semantics. | [`sync-wrapper-wait.journey.yaml`](../../3-reference/examples/sync-wrapper-wait.journey.yaml) |
| [Global compensation journey](global-compensation.md) | Attach a global compensation path that runs when a journey fails, times out, or is cancelled, using `spec.compensation` with access to final context and termination metadata. | [`http-compensation.journey.yaml`](../../3-reference/examples/http-compensation.journey.yaml) |
| [Subject-scoped self-service steps](subject-self-service.md) | Capture the subject from JWT at start, re-check it on follow-up steps, and fail with a security error on mismatch. | [`subject-step-guard.journey.yaml`](../../3-reference/examples/subject-step-guard.journey.yaml) |
| [Bounded loops & retries](loops-bounded-retries.md) | Model approval, document collection, and polling loops with explicit attempt counters and execution time limits. | [`approval-loop.journey.yaml`](../../3-reference/examples/approval-loop.journey.yaml), [`poll-status-api.journey.yaml`](../../3-reference/examples/poll-status-api.journey.yaml) |
| [Journey metadata (tags & attributes)](journey-metadata-tags-attributes.md) | Shape `context` using payload, headers, and `baggage` so the engine can populate journey tags and attributes for querying and correlation. | [`metadata-from-payload.journey.yaml`](../../3-reference/examples/metadata-from-payload.journey.yaml) |

For each use case, the dedicated page explains:
- The problem and context.
- The relevant DSL features (`task`, `choice`, `transform`, `wait`/`webhook`, `parallel`, `spec.errors`, etc.).
- How the example journey definition is structured, with key YAML snippets.
- How the per‑journey / per‑API OpenAPI export (`docs/3-reference/examples/oas/*.openapi.yaml`) surfaces the behaviour.
