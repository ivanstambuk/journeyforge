# JourneyForge – Engine & DSL Comparison

Status: Draft | Last updated: 2025-11-25

This document compares JourneyForge’s DSL and engine to several well-known orchestration systems:

- JourneyForge (this project)
- Camunda 8 (BPMN/DMN/Tasklist)
- Orkes Conductor
- Temporal
- AWS Step Functions (Amazon States Language)
- Google Cloud Workflows

The intent is:

- To make JourneyForge’s **scope and trade-offs explicit**, not to claim feature parity.
- To highlight which gaps are **intentional / out of scope** versus **real gaps** we may want to close over time.
- To show, where relevant, how a missing feature can be achieved via existing JourneyForge primitives or via the surrounding platform.

Legend for the “JourneyForge” column:

- **Yes** – Supported as a core DSL or engine capability.
- **Via pattern/platform** – Not a dedicated feature, but achievable via documented patterns (DSL) or via platform/runtime configuration.
- **No (Intentional)** – Explicitly out of scope for JourneyForge’s v1 focus on user-centric API journeys.
- **No (Real gap)** – Conceptually in scope for user-centric journeys but not yet supported; usually accompanied by a suggested workaround.

> This comparison is intentionally high level; it focuses on end-user-visible capabilities rather than internal implementation details.

## 1. Language & Control-Flow Capabilities (DSL)

| Category | Capability | [JourneyForge DSL](../3-reference/dsl.md) | [Camunda 8](https://docs.camunda.io/docs/components/modeler/bpmn/bpmn-coverage/) | [Orkes Conductor](https://orkes.io/content/developer-guides/workflows) | [Temporal](https://docs.temporal.io/workflows) | [AWS Step Functions](https://states-language.net/spec.html) | [Google Cloud Workflows](https://cloud.google.com/workflows/docs/reference/syntax) | Notes (JourneyForge perspective) |
|---------|------------|-------------|-----------|-----------------|----------|--------------------|------------------------------|----------------------------------|
| Scope & model | Primary modelling style | **Yes** – YAML/JSON DSL (“journey-as-config”) for `kind: Journey` and `kind: Api` with explicit states and context | Yes – BPMN/DMN models | Yes – JSON/YAML workflow definitions | No DSL; workflows are code in SDKs | Yes – JSON-based Amazon States Language (ASL) state machines | Yes – YAML/JSON-based workflow definitions | JourneyForge deliberately targets config-centric API journeys, not general-purpose code workflows. |
| Control flow | Static branching (`choice`) | **Yes** – DataWeave predicates on `choice` states | Yes – XOR gateways | Yes – decision tasks / switches | Yes – arbitrary code branches | Yes – `Choice` state | Yes – `switch` expressions | Core control-flow primitive; aligned in spirit with XOR gateways / code branches. |
| Control flow | Static parallel branches | **Yes** – `parallel` state with fixed branches and join semantics | Yes – AND gateways / parallel flows | Yes – `FORK_JOIN` | Yes – fan-out via code (`Promise.all` / equivalent) | Yes – `Parallel` state | Yes – `parallel` step | JourneyForge parallelism is intentionally limited to a **small fixed set** of branches per spec. |
| Control flow | Dynamic parallel fan-out (“for each item, in parallel”) | **No (Intentional)** – [ADR-0021](../6-decisions/ADR-0021-no-loop-state-dsl-v1.md) forbids dynamic parallel loops/map state; use DataWeave + explicit loops or external services | Yes – multi-instance activities | Yes – `FORK_JOIN_DYNAMIC` | Yes – arbitrary fan-out in code | Yes – `Map` state with `MaxConcurrency` | Yes – `for` loops with parallel iteration over collections (parallel steps) | For user-centric API journeys, high-cardinality fan-out is handled either by external services or by small-N explicit patterns; we deliberately avoid map-style states in v1. |
| Control flow | Structured loop primitives (for/while) | **Via pattern/platform** – Sequential loops via `choice` + counters in `context`, documented patterns in [ADR-0021](../6-decisions/ADR-0021-no-loop-state-dsl-v1.md); no `for`/`while` state | Limited – BPMN loop markers; more complex to execute | Yes – `DO_WHILE` | Yes – loops in code | Yes – graph cycles + `Map`; no dedicated `While` state | Yes – `for` loops (`for-range`/`for-in`); no dedicated `while` construct | We preserve a Lispy core: authors can loop using existing states without adding new loop semantics. |
| Case-style flow | Ad-hoc/case subprocess (unordered, optional activities) | **No (Intentional)** – All control-flow is explicit state machine wiring; case-style “pick any action any number of times” must be modelled via explicit states/loops | Yes – BPMN ad-hoc subprocesses for case management | Partially – can emulate via sub-workflows and task routing but no first-class ad-hoc construct | Partially – can express via code and Signals, not a distinct workflow type | No – must emulate via `Choice`/`Parallel`/loops and external systems | No – must emulate via explicit branching/loops and external systems | JourneyForge intentionally targets scripted user journeys, not ad-hoc/knowledge-worker case management. |
| Events & SLAs | Event-driven start (message/bus vs HTTP) | **Via pattern/platform** – Journeys start via HTTP; event-driven starts require external consumers that translate events into `POST /journeys/{journeyName}/start` calls | Yes – message start events and external triggers | Yes – event handlers can start workflows from queues/topics | Yes – workflows can be started from messages via workers/SDKs | Yes – state machines started from EventBridge/SNS/SQS/other AWS triggers | Partially – workflows started via HTTP/SDK and commonly triggered via Eventarc/Pub/Sub/Cloud Scheduler; not a first-class start event in the syntax | JourneyForge keeps the DSL centred on HTTP starts; event-driven initiation is handled by surrounding infrastructure. |
| Events & SLAs | Boundary events / scoped SLAs around segments | **Via pattern/platform** – No boundary-event syntax; scoped SLAs are modelled via `parallel` + `timer` + `choice` patterns and documented examples | Yes – timer/error/message boundary events and event subprocesses | Partially – SLA/timeout patterns via `FORK_JOIN` + timers; no explicit boundary-event construct | Partially – timers + cancellation scopes expressed in code | Partially – `Wait`/`Choice`/`Parallel` patterns; no boundary-event concept in ASL | Partially – explicit `sleep`/`switch`/`parallel` patterns; no boundary-event concept in Workflows | JourneyForge relies on explicit timer/parallel patterns for SLAs instead of attachable boundary-event constructs to keep the DSL small. |
| Subflows | Local subjourneys / subflows in same spec | **Yes** – `spec.subjourneys` + `type: subjourney` ([ADR-0020](../6-decisions/ADR-0020-subjourney-state-v1.md)) with explicit input mapping and mini-outcome support | Yes – embedded subprocesses | Yes – sub-workflows | Yes – local helper methods within workflow code | No – no named local subflows; reuse via states only | Yes – `subworkflows` defined in the same workflow | JourneyForge subjourneys are strictly intra-spec and synchronous in v1, focused on code organisation. |
| Subflows | Cross-definition reusable subflows / child workflows | **No (Intentional)** – No cross-spec `journeyRef` in v1; reuse across specs via HTTP Journeys API instead | Yes – call activities | Yes – sub-workflows | Yes – child workflows | Yes – nested Step Functions via `StartExecution` service integration | Yes – calling other workflows via connectors/APIs | We treat “other journeys” as APIs, keeping the public contract clearly HTTP-based instead of introducing internal child-journey lifecycle semantics. |
| Dynamic task selection | Choose task/state type at runtime (“dynamic task”) | **No (Intentional)** – State `type`/`task.kind` fixed in DSL; selection via explicit `choice` only | Partially – via expression-driven gateways | Yes – `DYNAMIC` task | Yes – arbitrary code paths | No – task type fixed; use `Choice` | No – task type fixed in the workflow definition; use `switch`/conditions | We prioritise static analyzability and OpenAPI export; dynamic task names are intentionally avoided. |
| Data & expressions | Expression language & computed fields | **Yes** – pluggable expression engines selected via `lang` (for example `dataweave`, `jsonata`, `jolt`, `jq`) for predicates and mappers ([ADR-0002](../6-decisions/ADR-0002-expression-language-dataweave.md), [ADR-0027](../6-decisions/ADR-0027-expression-engines-and-lang-extensibility.md), Feature 012) | Yes – FEEL and EL expressions in BPMN/DMN | Yes – JSONPath/SpEL-style expressions in task/workflow definitions | Yes – host language expressions in workflow code | Yes – JSONPath and intrinsic functions in ASL | Yes – Workflows expression language for conditions and transformations | JourneyForge standardises on a plugin-based expression engine model; concrete engine ids (`dataweave`, `jsonata`, `jolt`, `jq`) are enabled per deployment. |
| Data & expressions | Schemas & validation for inputs/outputs | **Yes** – JSON Schema 2020-12 for `spec.input.schema` / `spec.output.schema` and external OpenAPI schemas | Yes – BPMN/DMN with schema support via XML/XSD and integration | Partially – JSON schemas on inputs; less central to the model | Partially – typing enforced by Activities and host language types | Partially – JSON-based payloads; schema validation typically external | Partially – JSON schemas via API definitions; not central to the language | JourneyForge treats JSON Schema and OpenAPI as first-class for input/output modelling and example journeys. |
| Data & expressions | Secret references in definitions | **Yes** – secrets referenced opaquely via `secretRef` in dedicated security/auth blocks; no in-expression secret access | Partially – secrets via engine/platform integration and EL variables | Partially – secret references via configuration and external stores | Partially – secrets handled in Activity code and environment; not a workflow-language feature | Yes – Secrets Manager/Parameter Store integration via `secret`/`ssm` references | Yes – Secret Manager integration via connectors/configuration | JourneyForge deliberately avoids exposing secret values to expressions, keeping them confined to policy surfaces via `secretRef`. |
| External input | HTTP start of journeys | **Yes** – `POST /api/v1/journeys/{journeyName}/start` with `JourneyStartRequest/Response` and `startMode: sync or async` | Yes – REST or message start | Yes – REST start APIs | Yes – workflow start via SDK/HTTP | Partially – start via AWS APIs/SDKs; HTTP via API Gateway front-ends | Partially – start via Google Cloud APIs/SDKs; HTTP via API Gateway/Cloud Endpoints | Core entrypoint for user-centric API journeys. |
| API surface | First-class synchronous API endpoints (`kind: Api`, no `journeyId`) | **Yes** – `kind: Api` endpoints reuse the DSL but expose pure REST surfaces (for example `POST /api/v1/apis/{apiName}`) with ephemeral context and no `journeyId`/status/result endpoints ([ADR-0004](../6-decisions/ADR-0004-api-endpoints-kind-api.md)) | Partially – pure REST APIs are typically implemented in separate services/controllers that invoke BPMN processes; the BPMN model itself is not exposed as a first-class synchronous API endpoint | Partially – workflows are invoked from REST/gRPC frontends or gateways; workflow definitions are not themselves HTTP API endpoints | Partially – HTTP APIs are implemented in host applications that start workflows via SDKs; there is no `kind: Api`-style workflow type | Partially – REST APIs are defined via API Gateway/ALB and integrated with Step Functions as backends; state machines are not themselves defined as pure REST endpoints | Partially – REST APIs are defined via API Gateway/Cloud Endpoints and invoke Workflows; workflow definitions are not themselves declared as pure REST endpoints | JourneyForge supports both long-lived journeys and zero-journey, synchronous API endpoints in the same DSL, so authors can build composite APIs without exposing journey IDs or polling to clients. |
| External input | Explicit wait steps (manual input) | **Yes** – `wait` state with JSON Schema payload, context mappers, and step endpoints | Partially – user tasks; richer human-task model | Partially – human tasks; less standardised | Yes – via Signals/Updates/custom Activities | Partially – callback pattern (“wait for callback with task token”) to pause until an external actor responds; no rich human-task model | Yes – explicit callback endpoints via `events.create_callback_endpoint` + `events.await_callback` for human-in-the-loop and other external approvals | JourneyForge wait steps are low-level “input endpoints”; assignment/forms/UIs live outside the DSL. |
| External input | Webhook callbacks | **Yes** – `webhook` state with a fixed `/journeys/{journeyId}/steps/{stepId}` surface and security policies | Yes – message/callback events | Yes – webhook tasks | Yes – Signals/Activities; not first-class HTTP callbacks | Partially – callback pattern (`Task` with task token) plus API Gateway/Lambda | Yes – explicit callback endpoints via `events.create_callback_endpoint` + `events.await_callback`; callback URLs act as webhooks into workflows | JourneyForge optimises for direct callback URLs rather than general message-correlation semantics. |
| External input | General message-based interaction (signals/updates) | **No (Intentional)** – Interaction only at explicit `wait`/`webhook` states, plus cancel; no arbitrary signals | Yes – message events | Yes – signals | Yes – Signals/Queries/Updates | Partially – callbacks and EventBridge triggers; no general signal model | Partially – callbacks and Pub/Sub/Eventarc triggers; no general signal model | We intentionally keep interaction tied to explicit pause points to simplify reasoning and OpenAPI. |
| Human tasks | Rich human-task model (assignment, worklists, forms, escalation) | **No (Intentional)** – Only `wait`/`webhook` with JSON Schemas; no assignment, queues, or form DSL | Yes – user tasks + Tasklist + forms | Yes – human tasks | Partially – via Signals/Activities; no built-in Tasklist | No – human/task UIs built outside Step Functions; engine only exposes callback tokens for human-in-the-loop patterns | No – human/task UIs built outside Workflows; callbacks only, no Tasklist/forms layer | JourneyForge assumes a separate UI/work-queue layer built on top of the Journeys API, not a built-in Tasklist. |
| Error handling | Terminal success/failure (`succeed`/`fail`) | **Yes** – `succeed`/`fail` states, RFC9457-aligned error envelopes ([ADR-0003](../6-decisions/ADR-0003-error-model-rfc9457-problem-details.md)), `JourneyOutcome.phase` and `error` | Yes – end events + error events | Yes – terminal statuses | Yes – workflow completion + failure states | Yes – `Succeed`/`Fail` states | Partially – workflows end with a result or error; no dedicated `Succeed`/`Fail` states in the syntax | Canonical outcome model for user-centric journeys. |
| Error handling | Global compensation journey | **Yes** – `spec.compensation` ([ADR-0008](../6-decisions/ADR-0008-global-compensation-journey.md)) as a separate state machine run after non-success (and selected success) outcomes | Partially – compensation events; more granular | Partially – failure workflows | Partially – compensation via Activities/child workflows | Partially – explicit compensating `Task` states + error handling; no separate compensation graph | Partially – compensating workflows and steps modelled explicitly; no dedicated compensation graph construct | Coarse-grained SAGA semantics live in a single global compensation graph per journey definition. |
| Error handling | Per-step/per-subflow compensation semantics | **Via pattern/platform** – Subjourney mini-outcomes plus `onFailure.behavior` options such as capture or propagate; no dedicated `compensate` blocks in v1 | Yes – per-activity compensation handlers | Yes – per-task failure workflows | Yes – per-Activity/child patterns | Yes – per-state `Retry`/`Catch` blocks with compensating branches | Partially – compensating logic expressed via custom steps and external services; no dedicated compensate construct | We currently rely on global compensation and explicit patterns; finer-grained compensation is a possible future v2 feature. |
| Schedules | In-journey timers | **Yes** – `timer` state ([ADR-0018](../6-decisions/ADR-0018-timer-state.md)) for durable delays inside journeys | Yes – timer events | Yes – delay tasks | Yes – timers within workflows | Yes – `Wait` state | Yes – `sleep` and retry steps for delays inside workflows | Used to model SLAs, reminders, and races using existing control-flow constructs. |
| Schedules | Declarative schedule bindings | **Yes** – `task.kind: schedule:v1` to manage schedules that create new journey instances at intervals | Partially – via external schedulers / timers | Yes – first-class scheduler | Yes – Schedules / Cron | Partially – scheduled state machine executions via EventBridge/CloudWatch; not in ASL itself | Partially – workflows triggered via Cloud Scheduler/Eventarc/Pub/Sub; not part of the Workflows syntax itself | JourneyForge schedules are managed via a dedicated task kind and separate engine config; DSL keeps semantics intentionally simple (interval + startAt). |
| Loops & polling | Long-running HTTP polls | **Via pattern/platform** – `httpCall` + `timer` + loop patterns; no dedicated `httpPoll` state | Partially – via loops | Yes – `HTTP_POLL` | Yes – code+Activities | Via pattern – `Task` + `Wait` + `Choice` loop patterns | Via pattern – HTTP steps plus `sleep` and loop constructs; no dedicated HTTP poll state | JourneyForge exposes building blocks; polling patterns are documented examples rather than new state types. |
| Decision/rules | Decision tables / DMN | **No (Intentional)** – Only DataWeave expressions; decision services accessed via HTTP | Yes – DMN | Partially – rule tasks | No built-in DMN; rules in code/services | No – JSONPath/JSONata expressions only; decision services external | No – Workflows expression language only; decision services external | We expect complex rules to live in dedicated decision services (possibly DMN) behind HTTP. |
| Extensibility & plugins | Custom task/node plugins & extension points (tasks, expressions, UI) | **Yes** – spec-first Task Plugin SPI (`task.kind: <pluginType>:v<major>`) for all `type: task` states plus pluggable pure expression engines via `lang` (for example `dataweave`, JSONata, JOLT, `jq`); connectors are first-party plugins; no separate UI/modeler plugin surface in v1 | Yes – custom Service Tasks and Connectors via Connector SDK/element templates and FEEL expressions, plus Modeler plugin API for UI/tooling extensions | Yes – custom task workers in any language via Conductor/Orkes SDKs and built-in system tasks; UI is mainly configuration-driven rather than plugin-extensible | Yes – code-first Workflows and Activities in application code, with interceptors and middleware-style hooks instead of a DSL plugin catalogue | Partially – custom logic via Lambda and Activities plus a fixed set of service integrations and JSONPath/JSONata transforms; no user-defined state types or pluggable modeler extensions | Partially – steps call HTTP/GCP services via built-in connectors or Application Integration custom connectors; workflow editor is console-based without a general plugin model | JourneyForge keeps extensibility at the DSL/engine boundary via constrained Task/Expression plugins, rather than embedding arbitrary user code inside the engine or a heavy modeler plugin ecosystem. |
| Connectors | Built-in HTTP calls | **Yes** – `task.kind: httpCall:v1` with auth, resilience, and cookie-jar policies, plus OpenAPI-backed `operationRef` and request/response mappers | Partially – HTTP connector tasks and external workers | Yes – HTTP system tasks and worker-backed tasks | Yes – Activities calling HTTP services from workflow code | Yes – HTTP service integrations via Lambda and direct integrations | Yes – HTTP call steps via connectors/integrations | JourneyForge treats outbound HTTP as the primary connector surface, with strong policy and OpenAPI integration. |
| Connectors | Built-in Kafka/pub-sub event publish | **Yes** – `task.kind: kafkaPublish:v1` for Kafka topics (see [ADR-0006](../6-decisions/ADR-0006-event-publish-kafka.md)); consumption is handled by external services, not by the DSL | Partially – message events and external pub-sub connectors | Yes – Kafka/SQS/SNS-style event tasks and workers | Yes – Activities or external systems publishing/consuming messages | Yes – SNS/SQS/Kinesis integrations as system tasks | Yes – Pub/Sub/Eventarc integration via connectors | JourneyForge models outbound events directly; inbound/event-driven starts are delegated to surrounding infrastructure. |
| Connectors | Built-in cache operations (`cache:v1`) | **Yes** – cache task plugin (`task.kind: cache:v1`) for reading/writing entries in a single logical cache, with provider/TTL/eviction configured at the engine level and per-task TTL overrides in the DSL | Partially – cache patterns via external services or expression-level caching | Partially – cache via external stores or custom tasks | Partially – caching handled inside Activities or backing services; not a workflow-language feature | Partially – caching handled inside Lambda/backends or external caches; not a state-machine feature | Partially – caching handled by backend services or Cloud Memorystore/Cloud CDN; not a workflow-language feature | JourneyForge provides explicit cache operations to avoid redundant upstream calls and to share cached data across journey executions. |

## 2. Runtime & Platform Capabilities

| Category | Capability | [JourneyForge DSL](../3-reference/dsl.md) | [Camunda 8](https://docs.camunda.io/docs/components/modeler/bpmn/bpmn-coverage/) | [Orkes Conductor](https://orkes.io/content/developer-guides/workflows) | [Temporal](https://docs.temporal.io/workflows) | [AWS Step Functions](https://states-language.net/spec.html) | [Google Cloud Workflows](https://cloud.google.com/workflows/docs/reference/syntax) | Notes (JourneyForge perspective) |
|---------|------------|-------------|-----------|-----------------|----------|--------------------|------------------------------|----------------------------------|
| Deployment | Hosting model & portability | Self-managed Java 25 engine deployed as a service or embedded component; runs wherever the JVM runs (Kubernetes, VMs, on‑prem, any cloud); no managed SaaS offering in v1 | Self-managed Kubernetes cluster plus Camunda SaaS; portable across infrastructure when self-managed | Open-source Conductor engine that can be self-managed, plus Orkes Cloud as a managed SaaS | Open-source Temporal server for self-managed clusters, plus Temporal Cloud as a managed SaaS; portable across infrastructure when self-managed | Fully managed AWS regional service that runs only inside AWS accounts/regions | Fully managed Google Cloud regional service that runs only inside GCP projects/regions | JourneyForge behaves like an embeddable/self-managed component you run alongside your APIs, rather than a cloud-managed orchestration service tied to a single provider. |
| Deployment | Typical deployment role in architecture | Runs as a shared “journey platform” service (or small set of services) fronted by an API gateway; applications call it over HTTP/Kafka and it orchestrates downstream APIs rather than per-team worker queues | Deployed as a central workflow platform with Modeler/Operate/Tasklist UIs; business services start and are started by BPMN processes via REST/messages | Central workflow engine with workers that implement tasks; typically called from APIs/gateways or event streams | Temporal server cluster plus worker services that host workflow and Activity code inside application processes | State machines defined per workflow and invoked by AWS services, API Gateway, or SDKs inside an AWS application stack | Workflows defined per project and invoked via HTTP/SDK or triggered by GCP services such as Cloud Run, Pub/Sub, or Eventarc | JourneyForge is positioned as an HTTP/API journey layer in front of backend systems (and even other workflow engines), not as the primary compute/worker queue for arbitrary tasks. |
| Deployment | Cloud/vendor lock-in | **Low** – journeys and engine are portable across environments, with HTTP/Kafka as the main assumptions; no dependency on a specific cloud control plane | Medium – core engine is portable when self-managed, but Camunda SaaS and tooling create some ecosystem lock‑in | Medium – OSS engine is portable, while Orkes Cloud is tied to Orkes’ managed service and conventions | Medium – OSS server is portable, while Temporal Cloud is a managed service and applications depend on Temporal SDKs | High – deeply integrated with AWS IAM, SDKs, and service integrations; definitions and operations are AWS-specific | High – deeply integrated with Google Cloud IAM, connectors, and project/region scoping; definitions and operations are GCP-specific | JourneyForge deliberately avoids cloud-specific control-plane features so the same journey definitions can run wherever your HTTP APIs live; when you need deep AWS/GCP integration, Step Functions or Workflows may be a better fit. |
| Durability | Persistence across engine restarts | **Via pattern/platform** – DSL does not require durable history; engine implementations may persist timers/state but v1 does not define Temporal-like replay semantics | Yes – engine DB | Yes – DB + queues | Yes – durable event history + replay | Yes – durable state machine executions managed by AWS | Yes – managed workflow executions with durable state in Google Cloud | Durability is treated as a platform concern; the language does not expose history/replay as a model concept. |
| Durability | Event history, deterministic replay, Continue-As-New | **No (Intentional)** – No workflow code to replay; journeys are state machines with explicit outcomes and deadlines | No Temporal-style replay | No Temporal-style replay | Yes – core model | No Temporal-style replay; execution history available but not replayed in user code | No Temporal-style replay; execution history/logs available via Cloud Logging | JourneyForge targets simpler, short-to-medium journeys; we avoid the complexity of replay semantics in the DSL. |
| Verification | Testing & replayability of journeys | **Via pattern/platform** – Spec-first journeys executed via HTTP/CLI with captured inputs/contexts; no deterministic replay, but authors can re-run journeys from the same inputs or from snapshot fixtures, and rely on example journeys, OpenAPI/Arazzo contracts, and HTTP-level harnesses for regression testing | Partially – engine test libraries and process tests, plus Operate UI for instance history and re-runs; no deterministic replay of arbitrary user code | Partially – workflow re-runs and task mocking via workers and test tooling; UI exposes workflow graphs and history but not deterministic code replay | Yes – strong local workflow unit testing, deterministic replay of workflow code, and time-skipping/history-based debugging via SDKs and tooling | Partially – visual execution history and per-state input/output in the console, with support for re-running executions from the same or modified input; no deterministic code replay | Partially – console and logs show step-by-step execution and allow re-running workflows with different inputs; no deterministic replay beyond re-executing the workflow definition | JourneyForge leans on example journeys, HTTP contracts, and fixtures for testing; for full deterministic replay of arbitrary workflow code, Temporal remains the better fit. |
| Time & limits | Step-level vs HTTP-level vs workflow-level timeouts | **Yes** – HTTP task `timeoutMs` and resilience policies, plus global `spec.execution.maxDurationSec` and `onTimeout` handling; business SLAs are modelled via explicit `timer` states | Yes – timer events, per-activity timeouts, and process-level time constraints | Yes – per-task timeouts and workflow-level timeout configuration | Yes – rich Activity timeouts (Schedule-To-Start/Close, Heartbeat) and workflow run timeouts | Yes – step-level timeouts via `TimeoutSeconds` and overall execution limits via service configuration | Yes – step-level `sleep`/timeouts and overall execution time limits via Workflows/Cloud configuration | JourneyForge distinguishes HTTP step timeouts from global journey execution deadlines, with SLAs expressed via dedicated timer states rather than implicit timeouts. |
| Time & limits | Typical execution duration / journey length (coarse) | Designed for short-to-medium API journeys: from single-request flows up to flows that span minutes or hours with waits/timers and human steps; extremely long, multi-month “hyper-event-driven” lifecycles are considered out of scope for v1 | Supports long-running processes with timers/waits and human tasks; practical limits depend on engine configuration and infrastructure rather than strict hard caps | Supports long-running workflows with human tasks and external events; typical usage spans from seconds to days or longer based on storage/retention policies | Explicitly designed for long-running workflows (from seconds to years) with durable history and replay; effective limits are driven by storage and retention configuration | Supports long-running executions within AWS service limits (standard vs express), but very long-lived or highly chatty flows may require offloading state to S3 or other stores | Supports long-running executions within Workflows service limits (up to many hours/days), with practical constraints on payload size and call frequency; very long-lived flows may require external storage/services | JourneyForge targets journeys that are long-lived enough to include waits/timers and human interaction, but not unbounded multi-year event streams; for those, engines like Temporal or Conductor are a better fit. |
| Scaling & workers | General worker queues / arbitrary Activities | **No (Intentional)** – All external work is assumed to be behind HTTP/Kafka; no generic worker-task abstraction | Partially – external workers | Yes – workers for tasks | Yes – Activities executed by workers | Yes – Activity tasks and many direct AWS service integrations | Partially – tasks implemented via HTTP/Lambda/Cloud Functions; no generic worker-queue model in the language | Keeps the product focused on HTTP APIs as the integration boundary instead of general-purpose job queues. |
| Interaction | General signals/queries/updates into running instances | **No (Intentional)** – Only explicit `wait`/`webhook` + cancel; no general message handlers | Yes – message events | Yes – signals | Yes – Signals/Queries/Updates | Partially – callback APIs (`SendTask*`) and EventBridge; no general signal model | Partially – callback patterns and external triggers; no general signal/update model | Keeps interaction explicit and statically visible in the DSL and OpenAPI. |
| Visibility | Search/filter over instances | **Via pattern/platform** – Journey tags/attributes and context are available for indexing; query language and search semantics left to the platform | Yes – history DB + filters | Yes – search APIs | Yes – Search Attributes | Partially – list/filter executions via AWS APIs; no user-defined search attributes | Partially – list/filter executions via Cloud console/APIs; search largely driven by labels/logs | The engine exposes tags/attributes; search/query features are expected from the surrounding platform (Admin plane, UI). |
| Observability | Structured telemetry & metrics | **Via pattern/platform** – [ADR-0025](../6-decisions/ADR-0025-observability-and-telemetry-layers.md) defines telemetry layers; configuration is deployment-level, not part of the DSL | Yes – monitoring tools | Yes – monitoring | Yes – monitoring | Yes – CloudWatch metrics/logs and X-Ray integration | Yes – Cloud Logging, Cloud Monitoring, and Cloud Trace integration | JourneyForge keeps telemetry in ops config, not as per-journey DSL fields. |
| Scheduling | Rich calendar-based schedules, jitter, exclusions | **No (Intentional)** – Schedules use ISO-8601 durations + `startAt`; complex calendars are delegated to external schedulers or platform config | Partially – via timer events | Yes – advanced scheduler | Yes – advanced Schedules | Partially – EventBridge/CloudWatch schedules starting state machines | Partially – Cloud Scheduler/Eventarc/Pub/Sub starting workflows; not part of the workflow language | Simpler schedule model aligns with API-centric journeys; advanced cron semantics can live outside the DSL. |
| Governance | Version pinning & safe evolution for long-lived executions | **Via pattern/platform** – Journey definitions carry versions, but behaviour of running journeys across spec changes is governed by deployment policies and HTTP API design (for example versioned paths, headers, or query parameters), not by DSL constructs | Yes – versioned definitions and deployment policies | Yes – versioned workflows | Yes – build IDs + patching/versioning APIs | Partially – state machine versions/aliases and update APIs | Partially – workflow revisions and aliases; evolution managed via deployment config | For v1, we assume most journeys are not multi-month flows requiring Temporal-style patching; evolution policies belong in ADRs + platform. |
| Security & governance | Secret management & access policy surfaces | **Via pattern/platform** – secrets referenced opaquely via `secretRef` in dedicated security/auth blocks (no in-expression secrets), and access to journeys controlled via Journey Access Binding ([ADR-0014](../6-decisions/ADR-0014-journey-access-binding-and-session-semantics.md)); concrete secret stores and RBAC policies are defined at platform/config level, not in the DSL | Partially – secrets via engine/platform integration, plus BPMN access patterns and identity-aware APIs | Partially – secret handling via external stores and Conductor security config | Partially – secrets and access handled via code, service configs, and Temporal Cloud/cluster IAM; not a workflow-language concern | Yes – tight integration with IAM, Secrets Manager, and resource-based policies; access is managed via AWS IAM and service configuration, not ASL | Yes – tight integration with IAM, Secret Manager, and resource-based policies; access is managed via GCP IAM and service configuration, not the Workflows syntax | JourneyForge keeps secrets and journey access policy out of the expression space and in well-scoped policy blocks and platform configuration, avoiding ad-hoc secret usage in DSL text. |
| Security & governance | Inbound HTTP auth (JWT, mTLS, API key) | **Yes** – auth task plugins (`jwtValidate:v1`, `mtlsValidate:v1`, `apiKeyValidate:v1`) model inbound auth explicitly in the journey/API graph; transport boundary enforcement still lives in the surrounding platform. | Partially – inbound auth is typically handled by the web container/Spring Security or API gateways; BPMN/DMN models do not encode JWT/mTLS/API key policies | Partially – inbound auth handled via API Gateway/security config in front of Conductor; workflow definitions do not carry JWT/mTLS/API key policies | Partially – inbound auth handled at the Temporal server/cloud or fronting services; workflow code assumes an already-authenticated caller | Partially – IAM, Cognito, and API Gateway authorizers handle JWT/mTLS/API keys; ASL does not model inbound auth policies | Partially – IAM, Cloud Endpoints/API Gateway, and IAP handle JWT/mTLS/API keys; Workflows syntax does not model inbound auth policies | JourneyForge makes inbound auth constraints part of the journey definition via auth task plugins, while transport-level enforcement still lives in the surrounding platform. |
| Correlation | Business keys / correlation identifiers | **Via pattern/platform** – `journeyId` as technical key plus `journey.attributes.*` (for example subjectId, tenantId, orderId) for business-level correlation; no dedicated correlation-key field in the DSL | Yes – `businessKey` and correlation IDs in BPMN/engine APIs | Yes – workflow IDs and correlation IDs in the workflow model | Yes – `workflowId` and Search Attributes used as business keys | Partially – business IDs carried in input fields; correlation handled by surrounding services | Partially – business IDs in workflow input and labels; correlation handled by surrounding services | JourneyForge expects business correlation to be expressed via attributes and API contracts rather than a special correlation-key primitive. |
| Idempotency | Idempotent start/step semantics | **Via pattern/platform** – Idempotent behaviour is modelled via HTTP semantics and examples (for example idempotent POST/PUT patterns), not via first-class idempotency tokens in the DSL | Via external APIs/gateways and engine configuration rather than BPMN constructs | Partially – workflow start idempotency via Idempotency key and strategy; per-task idempotency via service design | Yes – idempotent workflow start semantics keyed by `workflowId`; activities rely on code-level idempotency | Partially – idempotency via API Gateway/Lambda patterns and service configuration | Partially – idempotency via fronting services (APIs/gateways) and backend design | JourneyForge treats idempotency as an HTTP/API design concern, illustrated in examples, not a DSL-level construct. |
| Tooling & integration | Journey/workflow contracts (OpenAPI/Arazzo) vs SDK-centric integration | **Yes** – spec-first OpenAPI 3.1 and Arazzo export for the Journeys API and per-journey HTTP surfaces derived directly from journey definitions (see [openapi-export.md](../4-architecture/spec-guidelines/openapi-export.md) / [openapi-binding.md](../4-architecture/spec-guidelines/openapi-binding.md)), enabling pure HTTP/JSON consumption of journeys without requiring a client SDK | No – BPMN/DMN workflow definitions are not directly exported as OpenAPI/Arazzo; workflow definitions are typically consumed via the engine and its SDKs/modeler, not as per-workflow HTTP contracts | Partially – workflow definitions can be invoked via REST/gRPC APIs with OpenAPI and client SDKs, but there is no first-class OpenAPI/Arazzo export of workflow contracts; worker model typically encourages SDK usage | No – workflow contracts are primarily defined and consumed via language SDKs; there is no OpenAPI/Arazzo export of workflow definitions | No – state machine definitions are not exported as OpenAPI/Arazzo; Step Functions integrates via AWS SDK/CLI and service integrations, not via per-workflow OpenAPI contracts | No – workflow definitions are not exported as OpenAPI/Arazzo; Workflows are invoked via HTTP/clients and GCP SDKs, with contracts documented separately | JourneyForge emphasises contract-first HTTP integration for journey *definitions* via OpenAPI/Arazzo, so clients can consume journeys with any HTTP stack without needing engine-specific SDKs; administrative APIs are out of scope for this row. |
| Ops features | Restart failed/completed executions (from start or mid-flow) | **Via pattern/platform** – No DSL-level restart semantics; operators can model restarts as new journey instances with copied input/context via the Admin/Journeys APIs | Partially – engine/Operate UIs can restart instances depending on configuration | Yes – restart APIs and `failureWorkflow` patterns | Yes – restart from beginning or specific points via APIs/SDKs | Partially – rerun executions or start new ones with same input; no explicit restart DSL | Partially – rerun or re-execute workflows from the beginning with same input; no mid-flow restart semantics | JourneyForge treats restart as an operational concern; the DSL does not define “restart from state X” semantics. |
| Ops features | Rate limiting & concurrency caps per journey | **Via pattern/platform** – Handled at gateway/platform layer (API management, rate limiters), not expressed in the DSL | Partially – via engine config | Yes – some rate limiting | Yes – per-workflow limits | Partially – concurrency limits and throttling via AWS quotas/config | Partially – concurrency and rate limiting via GCP quotas and fronting services (APIs/gateways) | JourneyForge intentionally keeps business-level rate/concurrency policies outside the language surface. |

## 3. Gap Classification Summary (JourneyForge vs Others)

This section summarises how we classify the main “missing” capabilities when comparing JourneyForge to Camunda 8, Orkes Conductor, Temporal, and AWS Step Functions.

- **Intentional gaps** – Features that are powerful but conflict with JourneyForge’s goals of a small, declarative, HTTP-centric DSL:
  - Dynamic parallel fan-out / map-style loops.
  - Dynamic task selection by name.
  - General worker/Activity queues beyond HTTP/Kafka.
  - Deterministic replay, event-history introspection, and Continue-As-New.
  - General signalling/query/update APIs into running journeys.
  - Rich human-task assignment/forms/queues inside the engine (Tasklist-style).
  - Complex calendar-based scheduling (holidays, jitter, exclusions).
  - DSL-level secret access and mutation.

- **Handled via patterns or platform** – Capabilities we consider in scope conceptually, but which are expressed using existing primitives or via platform configuration instead of new DSL constructs:
  - Sequential loops and HTTP polling (`choice` + `transform` + `timer` patterns).
  - Per-subjourney failure handling via mini-outcomes (`resultKind: outcome` + `onFailure.behavior`).
  - Global compensation journeys (`spec.compensation`), with finer-grained compensation expressed via patterns (see [ADR-0008](../6-decisions/ADR-0008-global-compensation-journey.md)).
  - Search and dashboards over journeys, powered by tags/attributes and external indexing.
  - Observability, metrics, and tracing ([ADR-0025](../6-decisions/ADR-0025-observability-and-telemetry-layers.md)) configured at deployment level.
  - Rate limiting, concurrency caps, and access policies at the API gateway / platform layer.

- **Real gaps (potential future work)** – Capabilities that look valuable for user-centric API journeys and may get first-class treatment in future versions:
  - DSL-level metadata for human tasks (`wait`/`webhook`) – e.g. titles, roles, and SLA hints to drive UI and observability, without changing engine semantics.
  - Clearer guidance and possibly very light sugar around SLA/timeouts for subjourneys and external-input states, built on existing `timer`/`parallel` patterns.
  - A small set of curated connectors (e.g. email, notifications) that build on top of `httpCall` but may deserve standardised naming and error handling in docs.

As JourneyForge evolves, any move from “Intentional” or “Via pattern/platform” into “core DSL feature” will be captured in ADRs under `docs/6-decisions/` and reflected back into this comparison.
