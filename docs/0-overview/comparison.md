# JourneyForge – Engine & DSL Comparison

Status: Draft | Last updated: 2025-11-24

This document compares JourneyForge’s DSL and engine to several well-known orchestration systems:

- JourneyForge (this project)
- Camunda 8 (BPMN/DMN/Tasklist)
- Orkes Conductor
- Temporal
- AWS Step Functions (Amazon States Language)
- Google Cloud Workflows

The intent is:

- To make JourneyForge’s **scope and trade-offs explicit**, not to claim feature parity.
- To highlight which gaps are **intentional / out of scope** versus **real gaps** we may want to close over time.
- To show, where relevant, how a missing feature can be achieved via existing JourneyForge primitives or via the surrounding platform.

Legend for the “JourneyForge” column:

- **Yes** – Supported as a core DSL or engine capability.
- **Via pattern/platform** – Not a dedicated feature, but achievable via documented patterns (DSL) or via platform/runtime configuration.
- **No (Intentional)** – Explicitly out of scope for JourneyForge’s v1 focus on user-centric API journeys.
- **No (Real gap)** – Conceptually in scope for user-centric journeys but not yet supported; usually accompanied by a suggested workaround.

> This comparison is intentionally high level; it focuses on end-user-visible capabilities rather than internal implementation details.

## 1. Language & Control-Flow Capabilities (DSL)

| Category | Capability | [JourneyForge DSL](../3-reference/dsl.md) | [Camunda 8](https://docs.camunda.io/docs/components/modeler/bpmn/bpmn-coverage/) | [Orkes Conductor](https://orkes.io/content/developer-guides/workflows) | [Temporal](https://docs.temporal.io/workflows) | [AWS Step Functions](https://states-language.net/spec.html) | [Google Cloud Workflows](https://cloud.google.com/workflows/docs/reference/syntax) | Notes (JourneyForge perspective) |
|---------|------------|-------------|-----------|-----------------|----------|--------------------|------------------------------|----------------------------------|
| Scope & model | Primary modelling style | **Yes** – YAML/JSON DSL (“journey-as-config”) for `kind: Journey` and `kind: Api` with explicit states and context | Yes – BPMN/DMN models | Yes – JSON/YAML workflow definitions | No DSL; workflows are code in SDKs | Yes – JSON-based Amazon States Language (ASL) state machines | Yes – YAML/JSON-based workflow definitions | JourneyForge deliberately targets config-centric API journeys, not general-purpose code workflows. |
| Control flow | Static branching (`choice`) | **Yes** – DataWeave predicates on `choice` states | Yes – XOR gateways | Yes – decision tasks / switches | Yes – arbitrary code branches | Yes – `Choice` state | Yes – `switch` expressions | Core control-flow primitive; aligned in spirit with XOR gateways / code branches. |
| Control flow | Static parallel branches | **Yes** – `parallel` state with fixed branches and join semantics | Yes – AND gateways / parallel flows | Yes – `FORK_JOIN` | Yes – fan-out via code (`Promise.all` / equivalent) | Yes – `Parallel` state | Yes – `parallel` step | JourneyForge parallelism is intentionally limited to a **small fixed set** of branches per spec. |
| Control flow | Dynamic parallel fan-out (“for each item, in parallel”) | **No (Intentional)** – [ADR-0021](../6-decisions/ADR-0021-no-loop-state-dsl-v1.md) forbids dynamic parallel loops/map state; use DataWeave + explicit loops or external services | Yes – multi-instance activities | Yes – `FORK_JOIN_DYNAMIC` | Yes – arbitrary fan-out in code | Yes – `Map` state with `MaxConcurrency` | Partially – `for` loops over collections; parallelism patterns available but no dedicated map state | For user-centric API journeys, high-cardinality fan-out is handled either by external services or by small-N explicit patterns; we deliberately avoid map-style states in v1. |
| Control flow | Structured loop primitives (for/while) | **Via pattern/platform** – Sequential loops via `choice` + counters in `context`, documented patterns in [ADR-0021](../6-decisions/ADR-0021-no-loop-state-dsl-v1.md); no `for`/`while` state | Limited – BPMN loop markers; more complex to execute | Yes – `DO_WHILE` | Yes – loops in code | Yes – graph cycles + `Map`; no dedicated `While` state | Yes – `for`/`while` constructs in the workflow syntax | We preserve a Lispy core: authors can loop using existing states without adding new loop semantics. |
| Case-style flow | Ad-hoc/case subprocess (unordered, optional activities) | **No (Intentional)** – All control-flow is explicit state machine wiring; case-style “pick any action any number of times” must be modelled via explicit states/loops | Yes – BPMN ad-hoc subprocesses for case management | Partially – can emulate via sub-workflows and task routing but no first-class ad-hoc construct | Partially – can express via code and Signals, not a distinct workflow type | No – must emulate via `Choice`/`Parallel`/loops and external systems | No – must emulate via explicit branching/loops and external systems | JourneyForge intentionally targets scripted user journeys, not ad-hoc/knowledge-worker case management. |
| Events & SLAs | Event-driven start (message/bus vs HTTP) | **Via pattern/platform** – Journeys start via HTTP; event-driven starts require external consumers that translate events into `POST /journeys/{journeyName}/start` calls | Yes – message start events and external triggers | Yes – event handlers can start workflows from queues/topics | Yes – workflows can be started from messages via workers/SDKs | Yes – state machines started from EventBridge/SNS/SQS/other AWS triggers | Via pattern/platform – workflows started via HTTP/SDK, often fronted by Eventarc, Pub/Sub, or Cloud Scheduler | JourneyForge keeps the DSL centred on HTTP starts; event-driven initiation is handled by surrounding infrastructure. |
| Events & SLAs | Boundary events / scoped SLAs around segments | **Via pattern/platform** – No boundary-event syntax; scoped SLAs are modelled via `parallel` + `timer` + `choice` patterns and documented examples | Yes – timer/error/message boundary events and event subprocesses | Partially – SLA/timeout patterns via `FORK_JOIN` + timers; no explicit boundary-event construct | Partially – timers + cancellation scopes expressed in code | Partially – `Wait`/`Choice`/`Parallel` patterns; no boundary-event concept in ASL | Partially – explicit `sleep`/`switch`/`parallel` patterns; no boundary-event concept in Workflows | JourneyForge relies on explicit timer/parallel patterns for SLAs instead of attachable boundary-event constructs to keep the DSL small. |
| Subflows | Local subjourneys / subflows in same spec | **Yes** – `spec.subjourneys` + `type: subjourney` ([ADR-0020](../6-decisions/ADR-0020-subjourney-state-v1.md)) with explicit input mapping and mini-outcome support | Yes – embedded subprocesses | Yes – sub-workflows | Yes – local helper methods within workflow code | No – no named local subflows; reuse via states only | Yes – `subworkflows` defined in the same workflow | JourneyForge subjourneys are strictly intra-spec and synchronous in v1, focused on code organisation. |
| Subflows | Cross-definition reusable subflows / child workflows | **No (Intentional)** – No cross-spec `journeyRef` in v1; reuse across specs via HTTP Journeys API instead | Yes – call activities | Yes – sub-workflows | Yes – child workflows | Yes – nested Step Functions via `StartExecution` service integration | Yes – calling other workflows via connectors/APIs | We treat “other journeys” as APIs, keeping the public contract clearly HTTP-based instead of introducing internal child-journey lifecycle semantics. |
| Dynamic task selection | Choose task/state type at runtime (“dynamic task”) | **No (Intentional)** – State `type`/`task.kind` fixed in DSL; selection via explicit `choice` only | Partially – via expression-driven gateways | Yes – `DYNAMIC` task | Yes – arbitrary code paths | No – task type fixed; use `Choice` | No – task type fixed in the workflow definition; use `switch`/conditions | We prioritise static analyzability and OpenAPI export; dynamic task names are intentionally avoided. |
| Data & expressions | Expression language & computed fields | **Yes** – DataWeave 2.x as the canonical expression language for predicates and mappers ([ADR-0002](../6-decisions/ADR-0002-expression-language-dataweave.md)) | Yes – FEEL and EL expressions in BPMN/DMN | Yes – JSONPath/SpEL-style expressions in task/workflow definitions | Yes – host language expressions in workflow code | Yes – JSONPath and intrinsic functions in ASL | Yes – Workflows expression language for conditions and transformations | JourneyForge standardises on DataWeave to keep one powerful, consistent expression surface across the DSL. |
| Data & expressions | Schemas & validation for inputs/outputs | **Yes** – JSON Schema 2020-12 for `spec.input.schema` / `spec.output.schema` and external OpenAPI schemas | Yes – BPMN/DMN with schema support via XML/XSD and integration | Partially – JSON schemas on inputs; less central to the model | Partially – typing enforced by Activities and host language types | Partially – JSON-based payloads; schema validation typically external | Partially – JSON schemas via API definitions; not central to the language | JourneyForge treats JSON Schema and OpenAPI as first-class for input/output modelling and example journeys. |
| Data & expressions | Secret references in definitions | **Yes** – secrets referenced opaquely via `secretRef` in dedicated security/auth blocks; no in-expression secret access | Partially – secrets via engine/platform integration and EL variables | Partially – secret references via configuration and external stores | Via pattern/platform – secrets handled in Activity code and environment | Yes – Secrets Manager/Parameter Store integration via `secret`/`ssm` references | Yes – Secret Manager integration via connectors/configuration | JourneyForge deliberately avoids exposing secret values to expressions, keeping them confined to policy surfaces via `secretRef`. |
| External input | HTTP start of journeys | **Yes** – `POST /api/v1/journeys/{journeyName}/start` with `JourneyStartRequest/Response` and `startMode: sync\|async` | Yes – REST or message start | Yes – REST start APIs | Yes – workflow start via SDK/HTTP | Partially – start via AWS APIs/SDKs; HTTP via API Gateway front-ends | Partially – start via Google Cloud APIs/SDKs; HTTP via API Gateway/Cloud Endpoints | Core entrypoint for user-centric API journeys. |
| API surface | First-class synchronous API endpoints (kind: Api, no journeyId) | **Yes** – `kind: Api` endpoints reuse the DSL but expose pure REST surfaces (for example `POST /api/v1/apis/{apiName}`) with ephemeral context and no `journeyId`/status/result endpoints ([ADR-0004](../6-decisions/ADR-0004-api-endpoints-kind-api.md)) | Via pattern/platform – pure REST APIs are typically implemented in separate services/controllers that invoke BPMN processes; the BPMN model itself is not exposed as a first-class synchronous API endpoint | Via pattern/platform – workflows are invoked from REST/gRPC frontends or gateways; workflow definitions are not themselves HTTP API endpoints | Via pattern/platform – HTTP APIs are implemented in host applications that start workflows via SDKs; there is no `kind: Api`-style workflow type | Via pattern/platform – REST APIs are defined via API Gateway/ALB and integrated with Step Functions as backends; state machines are not themselves defined as pure REST endpoints | Via pattern/platform – REST APIs are defined via API Gateway/Cloud Endpoints and invoke Workflows; workflow definitions are not themselves declared as pure REST endpoints | JourneyForge supports both long-lived journeys and zero-journey, synchronous API endpoints in the same DSL, so authors can build composite APIs without exposing journey IDs or polling to clients. |
| External input | Explicit wait steps (manual input) | **Yes** – `wait` state with JSON Schema payload, context mappers, and step endpoints | Partially – user tasks; richer human-task model | Partially – human tasks; less standardised | Yes – via Signals/Updates/custom Activities | No – `Wait` is time-based; manual input handled via external services/callback patterns | JourneyForge wait steps are low-level “input endpoints”; assignment/forms/UIs live outside the DSL. |
| External input | Webhook callbacks | **Yes** – `webhook` state with a fixed `/journeys/{journeyId}/steps/{stepId}` surface and security policies | Yes – message/callback events | Yes – webhook tasks | Yes – Signals/Activities; not first-class HTTP callbacks | Partially – callback pattern (`Task` with task token) plus API Gateway/Lambda | JourneyForge optimises for direct callback URLs rather than general message-correlation semantics. |
| External input | General message-based interaction (signals/updates) | **No (Intentional)** – Interaction only at explicit `wait`/`webhook` states, plus cancel; no arbitrary signals | Yes – message events | Yes – signals | Yes – Signals/Queries/Updates | Partially – callbacks and EventBridge triggers; no general signal model | We intentionally keep interaction tied to explicit pause points to simplify reasoning and OpenAPI. |
| Human tasks | Rich human-task model (assignment, worklists, forms, escalation) | **No (Intentional)** – Only `wait`/`webhook` with JSON Schemas; no assignment, queues, or form DSL | Yes – user tasks + Tasklist + forms | Yes – human tasks | Partially – via Signals/Activities; no built-in Tasklist | No – human/task UIs built outside Step Functions | JourneyForge assumes a separate UI/work-queue layer built on top of the Journeys API, not a built-in Tasklist. |
| Error handling | Terminal success/failure (`succeed`/`fail`) | **Yes** – `succeed`/`fail` states, RFC9457-aligned error envelopes ([ADR-0003](../6-decisions/ADR-0003-error-model-rfc9457-problem-details.md)), `JourneyOutcome.phase` and `error` | Yes – end events + error events | Yes – terminal statuses | Yes – workflow completion + failure states | Yes – `Succeed`/`Fail` states | Canonical outcome model for user-centric journeys. |
| Error handling | Global compensation journey | **Yes** – `spec.compensation` ([ADR-0008](../6-decisions/ADR-0008-global-compensation-journey.md)) as a separate state machine run after non-success (and selected success) outcomes | Partially – compensation events; more granular | Partially – failure workflows | Partially – compensation via Activities/child workflows | Partially – explicit compensating `Task` states + error handling; no separate compensation graph | Coarse-grained SAGA semantics live in a single global compensation graph per journey definition. |
| Error handling | Per-step/per-subflow compensation semantics | **Via pattern/platform** – Subjourney mini-outcomes + `onFailure.behavior: capture\|propagate`; no dedicated `compensate` blocks in v1 | Yes – per-activity compensation handlers | Yes – per-task failure workflows | Yes – per-Activity/child patterns | Yes – per-state `Retry`/`Catch` blocks with compensating branches | We currently rely on global compensation and explicit patterns; finer-grained compensation is a possible future v2 feature. |
| Schedules | In-journey timers | **Yes** – `timer` state ([ADR-0018](../6-decisions/ADR-0018-timer-state.md)) for durable delays inside journeys | Yes – timer events | Yes – delay tasks | Yes – timers within workflows | Yes – `Wait` state | Used to model SLAs, reminders, and races using existing control-flow constructs. |
| Schedules | Declarative schedule bindings | **Yes** – `task.kind: schedule` to manage schedules that create new journey instances at intervals | Partially – via external schedulers / timers | Yes – first-class scheduler | Yes – Schedules / Cron | Partially – scheduled state machine executions via EventBridge/CloudWatch; not in ASL itself | JourneyForge schedules are managed via a dedicated task kind and separate engine config; DSL keeps semantics intentionally simple (interval + startAt). |
| Loops & polling | Long-running HTTP polls | **Via pattern/platform** – `httpCall` + `timer` + loop patterns; no dedicated `httpPoll` state | Partially – via loops | Yes – `HTTP_POLL` | Yes – code+Activities | Via pattern – `Task` + `Wait` + `Choice` loop patterns | JourneyForge exposes building blocks; polling patterns are documented examples rather than new state types. |
| Decision/rules | Decision tables / DMN | **No (Intentional)** – Only DataWeave expressions; decision services accessed via HTTP | Yes – DMN | Partially – rule tasks | No built-in DMN; rules in code/services | No – JSONPath/JSONata expressions only; decision services external | We expect complex rules to live in dedicated decision services (possibly DMN) behind HTTP. |
| Connectors | Built-in HTTP calls | **Yes** – `task.kind: httpCall` with auth, resilience, and cookie-jar policies, plus OpenAPI-backed `operationRef` and request/response mappers | Partially – HTTP connector tasks and external workers | Yes – HTTP system tasks and worker-backed tasks | Yes – Activities calling HTTP services from workflow code | Yes – HTTP service integrations via Lambda and direct integrations | Yes – HTTP call steps via connectors/integrations | JourneyForge treats outbound HTTP as the primary connector surface, with strong policy and OpenAPI integration. |
| Connectors | Built-in Kafka/pub-sub event publish | **Yes** – `task.kind: eventPublish` for Kafka topics (see [ADR-0006](../6-decisions/ADR-0006-event-publish-kafka.md)); consumption is handled by external services, not by the DSL | Partially – message events and external pub-sub connectors | Yes – Kafka/SQS/SNS-style event tasks and workers | Yes – Activities or external systems publishing/consuming messages | Yes – SNS/SQS/Kinesis integrations as system tasks | Yes – Pub/Sub/Eventarc integration via connectors | JourneyForge models outbound events directly; inbound/event-driven starts are delegated to surrounding infrastructure. |
| Connectors | Built-in cache operations (`cacheGet`/`cachePut`) | **Yes** – cache resources and `task.kind: cacheGet`/`cachePut` for reading/writing named cache entries that can be shared across states and journey instances | Partially – cache patterns via external services or expression-level caching | Partially – cache via external stores or custom tasks | Via pattern/platform – caching handled inside Activities or backing services | Via pattern/platform – caching handled inside Lambda/backends or external caches | Via pattern/platform – caching handled by backend services or Cloud Memorystore/Cloud CDN | JourneyForge provides explicit cache operations to avoid redundant upstream calls and to share cached data across journey executions. |

## 2. Runtime & Platform Capabilities

| Category | Capability | [JourneyForge DSL](../3-reference/dsl.md) | [Camunda 8](https://docs.camunda.io/docs/components/modeler/bpmn/bpmn-coverage/) | [Orkes Conductor](https://orkes.io/content/developer-guides/workflows) | [Temporal](https://docs.temporal.io/workflows) | [AWS Step Functions](https://states-language.net/spec.html) | [Google Cloud Workflows](https://cloud.google.com/workflows/docs/reference/syntax) | Notes (JourneyForge perspective) |
|---------|------------|-------------|-----------|-----------------|----------|--------------------|------------------------------|----------------------------------|
| Durability | Persistence across engine restarts | **Via pattern/platform** – DSL does not require durable history; engine implementations may persist timers/state but v1 does not define Temporal-like replay semantics | Yes – engine DB | Yes – DB + queues | Yes – durable event history + replay | Yes – durable state machine executions managed by AWS | Yes – managed workflow executions with durable state in Google Cloud | Durability is treated as a platform concern; the language does not expose history/replay as a model concept. |
| Durability | Event history, deterministic replay, Continue-As-New | **No (Intentional)** – No workflow code to replay; journeys are state machines with explicit outcomes and deadlines | No Temporal-style replay | No Temporal-style replay | Yes – core model | No Temporal-style replay; execution history available but not replayed in user code | No Temporal-style replay; execution history/logs available via Cloud Logging | JourneyForge targets simpler, short-to-medium journeys; we avoid the complexity of replay semantics in the DSL. |
| Time & limits | Step-level vs HTTP-level vs workflow-level timeouts | **Yes** – HTTP task `timeoutMs` and resilience policies, plus global `spec.execution.maxDurationSec` and `onTimeout` handling; business SLAs are modelled via explicit `timer` states | Yes – timer events, per-activity timeouts, and process-level time constraints | Yes – per-task timeouts and workflow-level timeout configuration | Yes – rich Activity timeouts (Schedule-To-Start/Close, Heartbeat) and workflow run timeouts | Yes – step-level timeouts via `TimeoutSeconds` and overall execution limits via service configuration | Yes – step-level `sleep`/timeouts and overall execution time limits via Workflows/Cloud configuration | JourneyForge distinguishes HTTP step timeouts from global journey execution deadlines, with SLAs expressed via dedicated timer states rather than implicit timeouts. |
| Scaling & workers | General worker queues / arbitrary Activities | **No (Intentional)** – All external work is assumed to be behind HTTP/Kafka; no generic worker-task abstraction | Partially – external workers | Yes – workers for tasks | Yes – Activities executed by workers | Yes – Activity tasks and many direct AWS service integrations | Partially – tasks implemented via HTTP/Lambda/Cloud Functions; no generic worker-queue model in the language | Keeps the product focused on HTTP APIs as the integration boundary instead of general-purpose job queues. |
| Interaction | General signals/queries/updates into running instances | **No (Intentional)** – Only explicit `wait`/`webhook` + cancel; no general message handlers | Yes – message events | Yes – signals | Yes – Signals/Queries/Updates | Partially – callback APIs (`SendTask*`) and EventBridge; no general signal model | Partially – callback patterns and external triggers; no general signal/update model | Keeps interaction explicit and statically visible in the DSL and OpenAPI. |
| Visibility | Search/filter over instances | **Via pattern/platform** – Journey tags/attributes and context are available for indexing; query language and search semantics left to the platform | Yes – history DB + filters | Yes – search APIs | Yes – Search Attributes | Partially – list/filter executions via AWS APIs; no user-defined search attributes | Partially – list/filter executions via Cloud console/APIs; search largely driven by labels/logs | The engine exposes tags/attributes; search/query features are expected from the surrounding platform (Admin plane, UI). |
| Observability | Structured telemetry & metrics | **Via pattern/platform** – [ADR-0025](../6-decisions/ADR-0025-observability-and-telemetry-layers.md) defines telemetry layers; configuration is deployment-level, not part of the DSL | Yes – monitoring tools | Yes – monitoring | Yes – monitoring | Yes – CloudWatch metrics/logs and X-Ray integration | Yes – Cloud Logging, Cloud Monitoring, and Cloud Trace integration | JourneyForge keeps telemetry in ops config, not as per-journey DSL fields. |
| Scheduling | Rich calendar-based schedules, jitter, exclusions | **No (Intentional)** – Schedules use ISO-8601 durations + `startAt`; complex calendars are delegated to external schedulers or platform config | Partially – via timer events | Yes – advanced scheduler | Yes – advanced Schedules | Partially – EventBridge/CloudWatch schedules starting state machines | Partially – Cloud Scheduler/Eventarc/Pub/Sub starting workflows; not part of the workflow language | Simpler schedule model aligns with API-centric journeys; advanced cron semantics can live outside the DSL. |
| Governance | Version pinning & safe evolution for long-lived executions | **Via pattern/platform** – Journey definitions carry versions, but behaviour of running journeys across spec changes is governed by deployment policies and HTTP API design (for example versioned paths, headers, or query parameters), not by DSL constructs | Yes – versioned definitions and deployment policies | Yes – versioned workflows | Yes – build IDs + patching/versioning APIs | Partially – state machine versions/aliases and update APIs | Partially – workflow revisions and aliases; evolution managed via deployment config | For v1, we assume most journeys are not multi-month flows requiring Temporal-style patching; evolution policies belong in ADRs + platform. |
| Security & governance | Secret management & access policy surfaces | **Via pattern/platform** – secrets referenced opaquely via `secretRef` in dedicated security/auth blocks (no in-expression secrets), and access to journeys controlled via Journey Access Binding ([ADR-0014](../6-decisions/ADR-0014-journey-access-binding-and-session-semantics.md)); concrete secret stores and RBAC policies are defined at platform/config level, not in the DSL | Partially – secrets via engine/platform integration, plus BPMN access patterns and identity-aware APIs | Partially – secret handling via external stores and Conductor security config | Via pattern/platform – secrets and access handled via code, service configs, and Temporal Cloud/cluster IAM; not a workflow-language concern | Yes – tight integration with IAM, Secrets Manager, and resource-based policies; access is managed via AWS IAM and service configuration, not ASL | Yes – tight integration with IAM, Secret Manager, and resource-based policies; access is managed via GCP IAM and service configuration, not the Workflows syntax | JourneyForge keeps secrets and journey access policy out of the expression space and in well-scoped policy blocks and platform configuration, avoiding ad-hoc secret usage in DSL text. |
| Security & governance | Inbound HTTP auth policies (JWT, mTLS, API key) | **Yes** – `spec.policies.httpSecurity` defines reusable inbound auth policies (JWT validation, client certificate/mTLS, API keys) for `/journeys/...` and step endpoints, attached via `journeyPolicyRef` / `securityPolicyRef` (see section 18 of the DSL reference) | Via pattern/platform – inbound auth is typically handled by the web container/Spring Security or API gateways; BPMN/DMN models do not encode JWT/mTLS/API key policies | Via pattern/platform – inbound auth handled via API Gateway/security config in front of Conductor; workflow definitions do not carry JWT/mTLS/API key policies | Via pattern/platform – inbound auth handled at the Temporal server/cloud or fronting services; workflow code assumes an already-authenticated caller | Via pattern/platform – IAM, Cognito, and API Gateway authorizers handle JWT/mTLS/API keys; ASL does not model inbound auth policies | Via pattern/platform – IAM, Cloud Endpoints/API Gateway, and IAP handle JWT/mTLS/API keys; Workflows syntax does not model inbound auth policies | JourneyForge makes inbound auth constraints part of the journey definition via HTTP security policies, while concrete enforcement still lives in the engine and surrounding platform. |
| Correlation | Business keys / correlation identifiers | **Via pattern/platform** – `journeyId` as technical key plus `journey.attributes.*` (for example subjectId, tenantId, orderId) for business-level correlation; no dedicated correlation-key field in the DSL | Yes – `businessKey` and correlation IDs in BPMN/engine APIs | Yes – workflow IDs and correlation IDs in the workflow model | Yes – `workflowId` and Search Attributes used as business keys | Partially – business IDs carried in input fields; correlation handled by surrounding services | Partially – business IDs in workflow input and labels; correlation handled by surrounding services | JourneyForge expects business correlation to be expressed via attributes and API contracts rather than a special correlation-key primitive. |
| Idempotency | Idempotent start/step semantics | **Via pattern/platform** – Idempotent behaviour is modelled via HTTP semantics and examples (for example idempotent POST/PUT patterns), not via first-class idempotency tokens in the DSL | Via external APIs/gateways and engine configuration rather than BPMN constructs | Via external APIs/gateways and per-task configuration | Yes – idempotent workflow start semantics keyed by `workflowId`; activities rely on code-level idempotency | Partially – idempotency via API Gateway/Lambda patterns and service configuration | Partially – idempotency via fronting services (APIs/gateways) and backend design | JourneyForge treats idempotency as an HTTP/API design concern, illustrated in examples, not a DSL-level construct. |
| Tooling & integration | Journey/workflow contracts (OpenAPI/Arazzo) vs SDK-centric integration | **Yes** – spec-first OpenAPI 3.1 and Arazzo export for the Journeys API and per-journey HTTP surfaces derived directly from journey definitions (see [openapi-export.md](../4-architecture/spec-guidelines/openapi-export.md) / [openapi-binding.md](../4-architecture/spec-guidelines/openapi-binding.md)), enabling pure HTTP/JSON consumption of journeys without requiring a client SDK | No – BPMN/DMN workflow definitions are not directly exported as OpenAPI/Arazzo; workflow definitions are typically consumed via the engine and its SDKs/modeler, not as per-workflow HTTP contracts | Partially – workflow definitions can be invoked via REST/gRPC APIs with OpenAPI and client SDKs, but there is no first-class OpenAPI/Arazzo export of workflow contracts; worker model typically encourages SDK usage | No – workflow contracts are primarily defined and consumed via language SDKs; there is no OpenAPI/Arazzo export of workflow definitions | No – state machine definitions are not exported as OpenAPI/Arazzo; Step Functions integrates via AWS SDK/CLI and service integrations, not via per-workflow OpenAPI contracts | No – workflow definitions are not exported as OpenAPI/Arazzo; Workflows are invoked via HTTP/clients and GCP SDKs, with contracts documented separately | JourneyForge emphasises contract-first HTTP integration for journey *definitions* via OpenAPI/Arazzo, so clients can consume journeys with any HTTP stack without needing engine-specific SDKs; administrative APIs are out of scope for this row. |
| Ops features | Restart failed/completed executions (from start or mid-flow) | **Via pattern/platform** – No DSL-level restart semantics; operators can model restarts as new journey instances with copied input/context via the Admin/Journeys APIs | Partially – engine/Operate UIs can restart instances depending on configuration | Yes – restart APIs and `failureWorkflow` patterns | Yes – restart from beginning or specific points via APIs/SDKs | Partially – rerun executions or start new ones with same input; no explicit restart DSL | Partially – rerun or re-execute workflows from the beginning with same input; no mid-flow restart semantics | JourneyForge treats restart as an operational concern; the DSL does not define “restart from state X” semantics. |
| Ops features | Rate limiting & concurrency caps per journey | **Via pattern/platform** – Handled at gateway/platform layer (API management, rate limiters), not expressed in the DSL | Partially – via engine config | Yes – some rate limiting | Yes – per-workflow limits | Partially – concurrency limits and throttling via AWS quotas/config | Partially – concurrency and rate limiting via GCP quotas and fronting services (APIs/gateways) | JourneyForge intentionally keeps business-level rate/concurrency policies outside the language surface. |

## 3. Gap Classification Summary (JourneyForge vs Others)

This section summarises how we classify the main “missing” capabilities when comparing JourneyForge to Camunda 8, Orkes Conductor, Temporal, and AWS Step Functions.

- **Intentional gaps** – Features that are powerful but conflict with JourneyForge’s goals of a small, declarative, HTTP-centric DSL:
  - Dynamic parallel fan-out / map-style loops.
  - Dynamic task selection by name.
  - General worker/Activity queues beyond HTTP/Kafka.
  - Deterministic replay, event-history introspection, and Continue-As-New.
  - General signalling/query/update APIs into running journeys.
  - Rich human-task assignment/forms/queues inside the engine (Tasklist-style).
  - Complex calendar-based scheduling (holidays, jitter, exclusions).
  - DSL-level secret access and mutation.

- **Handled via patterns or platform** – Capabilities we consider in scope conceptually, but which are expressed using existing primitives or via platform configuration instead of new DSL constructs:
  - Sequential loops and HTTP polling (`choice` + `transform` + `timer` patterns).
  - Per-subjourney failure handling via mini-outcomes (`resultKind: outcome` + `onFailure.behavior`).
  - Global compensation journeys (`spec.compensation`), with finer-grained compensation expressed via patterns (see [ADR-0008](../6-decisions/ADR-0008-global-compensation-journey.md)).
  - Search and dashboards over journeys, powered by tags/attributes and external indexing.
  - Observability, metrics, and tracing ([ADR-0025](../6-decisions/ADR-0025-observability-and-telemetry-layers.md)) configured at deployment level.
  - Rate limiting, concurrency caps, and access policies at the API gateway / platform layer.

- **Real gaps (potential future work)** – Capabilities that look valuable for user-centric API journeys and may get first-class treatment in future versions:
  - DSL-level metadata for human tasks (`wait`/`webhook`) – e.g. titles, roles, and SLA hints to drive UI and observability, without changing engine semantics.
  - Clearer guidance and possibly very light sugar around SLA/timeouts for subjourneys and external-input states, built on existing `timer`/`parallel` patterns.
  - A small set of curated connectors (e.g. email, notifications) that build on top of `httpCall` but may deserve standardised naming and error handling in docs.

As JourneyForge evolves, any move from “Intentional” or “Via pattern/platform” into “core DSL feature” will be captured in ADRs under `docs/6-decisions/` and reflected back into this comparison.
